module ntt;

macro import std.macro.assert;
macro import std.macro.listcomprehension;

import std.algorithm;
import std.process;
import std.stdio;
import std.string;

alias pingIntervalMinutes = 30;

void main(string[] args) {
    if (args.length < 2 || args[1] == "status")
        return cmdStatus;
    else if (args[1] == "sleep")
        cmdSleep;
    else if (args[1] == "work" || args[1] == "w")
        cmdWork(args[2 .. $]);
    else if (args[1] == "break" || args[1] == "b")
        cmdBreak(args[2 .. $]);
    else
        usage;
}

void usage() {
    print("Usage: ntt <command> [<args>]");
    print("    status                     Display today's work stats (default command)");
    print("    sleep                      Delay until the time of next task ping");
    print("    work ([task] ([message]))  Mark last ping as worked on task");
    print("    break ([message])          Mark last ping as break time");
}

/// Display today's work status.
void cmdStatus() {
    print("TODO");
}

void cmdWork(string[] args) {
    print("TODO");
}

void cmdBreak(string[] args) {
    print("TODO");
}

string logPath() {
    auto path = getEnv("XDG_DATA_HOME").notEmpty? else "$(getEnv("HOME"))/.local/share";
    return "$(path)/ntt";
}

struct Entry {
    /// Time of entry in unix time, corresponds to pings.
    long time;
    string task;
    long durationMin;
    string comment;

    static (Entry | :else) fromString(string s) {
        auto words = s.words;
        // Must have timestamp, task and duration.
        if (words.length < 3)
            return :else;
        auto time = parseDate(words[0])? else return :else;
        auto task = words[1];
        auto durationMin = words[2].parseScalar("min")? else return :else;

        return Entry(time, task, durationMin, words[3 .. $].join(" "));
    }

    string toString() => "$(formattedTime(time))  $task  $(durationMin)min  $comment".strip;
}

unittest {
    assert(Entry.fromString("") == :else);
    assert(Entry.fromString("# Some comment dunno") == :else);
    assert(Entry.fromString("2024-03-13T10:09:06+0200  ntt.base  15min") ==
        Entry(1710317346, "ntt.base", 15, ""));
    assert(Entry.fromString("2024-03-13T10:09:06+0200  ntt.base  15nmin") ==
        :else);
}

/// Sleep until it's time to ping
void cmdSleep() {
    print("Sleeping until next ping, average wake interval is $pingIntervalMinutes min");
    long startTime = unixTime;
    long targetTime = nextPing(pingIntervalMinutes * 60, startTime);

    // Don't try to sleep all the way to the target time at once, instead take
    // short naps and keep watching the clock. The OS might get suspended at
    // any time and that will screw up the timing of a long sleep.
    while (unixTime < targetTime) {
        sleep(10);
    }

    print("Pinged at $(formattedTime(targetTime)).");
}

/// Unix time of next ping from now given average ping interval.
long nextPing(long avgSecs, long now) {
    mut long ret = now + 1;
    while (!isPing(avgSecs, ret)) ++ret;
    return ret;
}

/// Unix time of previous ping from now given average ping interval.
long prevPing(long avgSecs, long now) {
    mut long ret = now - 1;
    while (!isPing(avgSecs, ret)) --ret;
    return ret;
}

bool isPing(long avgSecs, long t) {
  // This is the xorshift64 algorithm.

  mut long t = t;
  t ^= t << 13;
  t ^= t >> 7;
  t ^= t << 17;
  return (t % avgSecs) == 0;
}

string formattedTime(long unixTime) =>
    "date -d @$(unixTime) +'%Y-%m-%dT%H:%M:%S%z'".readback.strip;

(long | :else) parseDate(string datestring) {
    if (datestring.strip == "") {
        return :else;
    }

    if (datestring.strip.startsWith("#")) {
        return :else;
    }

    return "date -d $datestring -u +%s".readbackErr.case(
        int i: :else,
        string s: s.parseNum?.(:else if (that <= 0 || that > 99999999999) else that));
}

unittest
{
    assert(parseDate("2006-01-02T15:04:05-0700") == 1136239445);
    assert(parseDate("xyzzy") == :else);
    assert(parseDate("") == :else);
    assert(parseDate("9300-01-01") == :else);
}

long unixTime() => "date +%s".readback.atoi;

extern(C) int sleep(int);

// A version of readback that handles error code return values.
// FIXME: Replace with a stdlib version once one is available.
(int | string) readbackErr(string command) {
    import std.file : readText, remove;
    import std.string : toStringz;

    auto tmp = tmpnam(null).cToString;
    // XXX: Add hack to pipe stderr to devnull, otherwise date will make noise
    // about bad dates to our stderr.
    int iret = neat_runtime_system_iret(command ~ " > " ~ tmp ~ " 2> /dev/null");
    auto ret = readText(tmp);
    remove(tmp);
    if (iret)
        return iret;
    return ret;
}

private extern(C) char* tmpnam(char*);
private extern(C) int neat_runtime_system_iret(string command);

string[] words(string s) => [a for a in s.split(" ") where !a.empty];

(long | :else) parseScalar(string s, string unit) {
    string scalar = s[0 .. $ - unit.length] if s.endsWith(unit) else return :else;
    return scalar.parseNum;
}

unittest {
    assert("15min".parseScalar("min") == 15);
    assert("".parseScalar("min") == :else);
    assert("15".parseScalar("min") == :else);
    assert("15nmin".parseScalar("min") == :else);
}

/// Robust integer parser.
(long | :else) parseNum(string s) {
    import neat.runtime : atol;

    auto s = s.strip;
    long ret = atol(s);
    return ret if "$ret" == s else :else;
}

unittest {
    assert(parseNum("123") == 123);
    assert(parseNum("-123") == -123);
    assert(parseNum("-") == :else);
    assert(parseNum("") == :else);
    assert(parseNum("123gfp") == :else);
    assert(parseNum("a123") == :else);
}

alias notEmpty = a => a if !a.empty else :else;
