module ntt;

macro import std.macro.assert;
macro import std.macro.listcomprehension;

import std.argparse;
import std.error;
import std.file;
import std.process;
import std.stdio;
import std.string;

alias pingIntervalMinutes = 45;

void main(string[] args) {
    if (args.length < 2)
        return cmdStatus(args[1 .. $]);
    else if (args[1] == "status")
        return cmdStatus(args[2 .. $]);
    else if (args[1] == "sleep")
        cmdSleep;
    else if (args[1] == "task" || args[1] == "t")
        cmdTask(args[2 .. $]);
    else if (args[1] == "break" || args[1] == "b")
        cmdBreak(args[2 .. $]);
    else
        usage;
}

void usage() {
    print("Usage: ntt <command> [<args>]");
    print("    status                     Display current status (default command)");
    print("      --minimal                  Display only unaccounted ping count");
    print("    sleep                      Delay until the time of next task ping");
    print("    task [id] ([message])      Mark last ping as worked on task [id]");
    print("    break ([message])          Mark last ping as break time");
}

void cmdStatus(string[] args) {
    auto parser = new UnixArgParser;
    parser.add("m", "minimal", :noArg, "Display only unaccounted ping count");

    // TODO: Print usage instead of just crashing (need to rewrite case block
    // to allow multi-statement response)
    auto result = parser.parse(args)
        .case(Error: assert(false));

    auto pings = logPath.readLines.pings;
    auto unaccounted = pings.unaccountedPings;

    if (result.has("minimal")) {
        if (!unaccounted.empty)
            print("$(unaccounted.length)");
        return;
    }

    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
    } else if (!pings.dayIsStarted) {
        print("Nothing logged today yet, tag the last ping to start working.");
    } else {
        print("Unaccounted pings after last entry today:");
        for (p in unaccounted) {
            print("* $(p.formatTime("%H:%M:%S"))");
        }
    }
}

void cmdTask(string[] args) {
    if (args.empty) {
        usage();
        return;
    }

    auto pings = logPath.readLines.pings;
    auto unaccounted = pings.unaccountedPings;

    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
        return;
    }

    if (pings.dayIsStarted) {
        // Not the first entry, fill in breaks.
        for (auto i in 0 .. unaccounted.length - 1) {
            Entry(unaccounted[i], "break", pingIntervalMinutes, "").appendToLog;
        }
        if (unaccounted.length > 1)
            print("Added $(unaccounted.length - 1) breaks");
    }

    Entry(unaccounted[$ - 1], args[0], pingIntervalMinutes, args[1 .. $].join(" ")).appendToLog;
    print("Clocked $(pingIntervalMinutes)m on $(args[0]) at $(unaccounted[$ - 1].formatTime("%H:%M:%S"))");
}

void cmdBreak(string[] args) {
    auto pings = logPath.readLines.pings;
    auto unaccounted = pings.unaccountedPings;

    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
        return;
    }

    if (pings.dayIsStarted) {
        // Not the first entry, fill in breaks.
        for (auto i in 0 .. unaccounted.length - 1) {
            Entry(unaccounted[i], "break", pingIntervalMinutes, "").appendToLog;
        }
        if (unaccounted.length > 1)
            print("Added $(unaccounted.length - 1) breaks");
    }

    Entry(unaccounted[$ - 1], "break", pingIntervalMinutes, args[0 .. $].join(" ")).appendToLog;
    print("Clocked break at $(unaccounted[$ - 1].formatTime("%H:%M:%S"))");
}

string[] readLines(string path) => path.readText.strip.split("\n") if path.exists else [];

void writeLines(string[] lines, string path) => path.writeText(lines.join("\n"));

string logPath() {
    auto path = getEnv("XDG_DATA_HOME").notEmpty? else "$(getEnv("HOME"))/.local/share";
    return "$(path)/ntt/ntt.timedot";
}

struct Entry {
    /// Time of entry in unix time, corresponds to pings.
    long time;
    string task;
    long durationMin;
    string comment;

    string toString() {
        auto task = "# break" if this.task == "break" else this.task;
        return "$task  $(durationMin)m  ; $(time.timeOfDay)  $(comment)".strip();
    }

    bool isTask() => task != "break";

    void appendToLog() {
        if (!logPath.exists)
            system("mkdir -p $(logPath.dirname)");
        assert(logPath.dirname.exists);

        // TODO Use append-to-file op instead of full file rewrite
        mut auto lines = logPath.readLines;

        // Do we need to mark a new day?
        if (lines.latestDay != time.day) {
            if (!lines.empty)
                lines ~= "";

            lines ~= "$(time.day)";
        }

        lines ~= "$this";
        lines.writeLines(logPath);
    }
}

long[] pings(string[] log) {
    mut auto day = "";
    mut long[] result = [];

    for (line in log) {
        if (auto newDay = line.strip().parseDay?) {
            day = newDay;
            continue;
        }

        // Nothing happens until the first day is declared.
        if (day == "")
            continue;

        // Look for "; 12:30:45+0200"
        auto parts = line.split("; ");
        if (parts.length < 2)
            continue;
        auto words = parts[1].words;
        if (words.empty)
            continue;

        // Try to compose day and first word after comment into a valid
        // timestamp. Declare a ping if this succeeds.
        result ~= "$(day)T$(words[0])".parseTime("%Y-%m-%dT%H:%M:%S%z")? else continue;
    }

    return result;
}

string latestDay(string[] log) {
    mut auto result = "";
    for (line in log) {
        if (auto newDay = line.strip().parseDay?)
            result = newDay;
    }
    return result;
}

long[] unaccountedPings(long[] pings) {
    auto today = now.day;
    auto limit = [max(t) for t in pings];
    mut long[] result;
    mut long t = now.prevPing;
    while (t > limit && t.day == today) {
        result ~= t;
        t = t.prevPing;
    }

    return result.reversed;
}


bool dayIsStarted(long[] pings) => [max(p) for p in pings ~ [0]].day == now.day;

/// Sleep until it's time to ping
void cmdSleep() {
    print("Sleeping until next ping, average ping interval is $pingIntervalMinutes min");
    long targetTime = now.nextPing;

    // Don't try to sleep all the way to the target time at once, instead take
    // short naps and keep watching the clock. The OS might get suspended at
    // any time and that will screw up the timing of a long sleep.
    while (now < targetTime) {
        sleep(10);
    }

    print("Pinged at $(targetTime.formatTime("%H:%M:%S")).");
}

/// Unix time of next ping from now given average ping interval.
long nextPing(long t) {
    mut long ret = t + 1;
    while (!isPing(pingIntervalMinutes * 60, ret)) ++ret;
    return ret;
}

/// Unix time of previous ping from now given average ping interval.
long prevPing(long t) {
    mut long ret = t - 1;
    while (!isPing(pingIntervalMinutes * 60, ret)) --ret;
    return ret;
}

bool isPing(long avgSecs, long t) {
  // This is the xorshift64 algorithm.

  mut long t = t;
  t ^= t << 13;
  t ^= t >> 7;
  t ^= t << 17;
  return (t % avgSecs) == 0;
}

/// Parse timedot date formats.
(string | :else) parseDay(string simpleDate) {
    alias normalized = "%Y-%m-%d";

    simpleDate.parseTime("%Y-%m-%d").case(long s: return s.formatTime(normalized));
    simpleDate.parseTime("%Y.%m.%d").case(long s: return s.formatTime(normalized));
    simpleDate.parseTime("%Y/%m/%d").case(long s: return s.formatTime(normalized));
    return :else;
}

unittest {
    assert(parseDay("2010-01-30") == "2010-01-30");
    assert(parseDay("2010/1/30") == "2010-01-30");
    assert(parseDay("2010.1.30") == "2010-01-30");
    assert(parseDay("teapot") == :else);
}

/// Get current unix time.
long now() => time(null);
extern(C) long time(void*);

/// Day of unix time in current time zone.
string day(long unixTime) => unixTime.formatTime("%Y-%m-%d");

/// Time of day of unix time in current time zone.
string timeOfDay(long unixTime) => unixTime.formatTime("%H:%M:%S%z");

extern(C) int sleep(int);

import c.sys.time : tm;

/// strptime wrapper that reads directly into unix time
(long | :else) parseTime(string timestamp, string fmt) {
    import std.string : toStringz;

    mut tm result;

    if (strptime(timestamp.toStringz, fmt.toStringz, &result) == null)
        return :else;

    return mktime(&result);
}

private extern(C) char* strptime(char*, char*, tm*);
private extern(C) long mktime(tm*);

unittest {
    assert("2024-03-15T12:44:52+0200".parseTime("%Y-%m-%dT%H:%M:%S%z") == 1710499492);
    assert("potato".parseTime("%Y-%m-%dT%H:%M:%S%z") == :else);
}

string formatTime(long unixTime, string fmt) {
    import std.string : toStringz;

    mut long t = unixTime;
    auto buf = new char mut[](64);
    mut tm result;
    localtime_r(&t, &result);
    strftime(buf.ptr, buf.length, fmt.toStringz, &result);

    return buf.ptr.cToString;
}

private extern(C) size_t strftime(char*, size_t, char*, tm*);
private extern(C) tm* localtime_r(long* timep, tm* result);

unittest {
    assert(1710499492.formatTime("%Y-%m-%dT%H:%M:%S%z") == "2024-03-15T12:44:52+0200");
}

string[] words(string s) => [a for a in s.split(" ") where !a.empty];

T[] reversed(T)(T[] xs) => [xs[$ - i - 1] for i in 0..xs.length];

unittest {
    int[] empty = [];   // Need to use a var so the generic type is fixed.
    assert(reversed(empty) == empty);

    assert(reversed([1, 2, 3]) == [3, 2, 1]);
    assert(reversed([1, 2, 3, 4]) == [4, 3, 2, 1]);
}

alias notEmpty = a => a if !a.empty else :else;
