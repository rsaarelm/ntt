module ntt;

macro import std.macro.assert;
macro import std.macro.listcomprehension;

import std.process;
import std.stdio;
import std.string;

alias pingIntervalMinutes = 30;

void main() {
    // TODO Cmd parser, sleep at "sleep" cmd only.
    cmdSleep;
}

struct Entry {
    /// Time of entry in unix time, corresponds to pings.
    long time;
    string task;
    int durationMin;
    string comment;

    static (Entry | :else) fromString(string s) {
        auto words = s.split(" ");
        // Must have timestamp, task and duration.
        if (words.length < 3)
            return :else;
        auto time = parseDate(words[0])?;
        return :else;
    }
}

unittest {
    assert(Entry.fromString("") == :else);
    assert(Entry.fromString("# Some comment dunno") == :else);
    assert(Entry.fromString("2024-03-13T10:09:06+0200  ntt.base  15min") ==
        Entry(12345, "ntt.base", 15, ""));
    assert(Entry.fromString("2024-03-13T10:09:06+0200  ntt.base  15nmin") ==
        :else);
}

/// Sleep until it's time to ping
void cmdSleep() {
    print("Sleeping until next ping, average wake interval is $(pingIntervalMinutes) min");
    long startTime = unixTime;
    long targetTime = nextPing(pingIntervalMinutes * 60, startTime);

    // Don't try to sleep all the way to the target time at once, instead take
    // short naps and keep watching the clock. The OS might get suspended at
    // any time and that will screw up the timing of a long sleep.
    while (unixTime < targetTime) {
        sleep(10);
    }

    print("Pinged at $(formattedTime(targetTime)).");
}

/// Unix time of next ping from now given average ping interval.
long nextPing(long avgSecs, long now) {
    mut long ret = now + 1;
    while (!isPing(avgSecs, ret)) ++ret;
    return ret;
}

/// Unix time of previous ping from now given average ping interval.
long prevPing(long avgSecs, long now) {
    mut long ret = now - 1;
    while (!isPing(avgSecs, ret)) --ret;
    return ret;
}

bool isPing(long avgSecs, long t) {
  // This is the xorshift64 algorithm.

  mut long t = t;
  t ^= t << 13;
  t ^= t >> 7;
  t ^= t << 17;
  return (t % avgSecs) == 0;
}

string formattedTime(long unixTime) =>
    "date -d @$(unixTime) +'%Y-%m-%dT%H:%M:%S%z'".readback;

(long | :else) parseDate(string datestring) {
    if (datestring.strip() == "") {
        return :else;
    }

    if (datestring.strip().startsWith("#")) {
        return :else;
    }

    return "date -d $(datestring) -u +%s".readbackErr.case(
        int i: :else,
        string s: s.atol.(:else if (that <= 0 || that > 99999999999) else that));
}

unittest
{
    assert(parseDate("2006-01-02T15:04:05-0700") == 1136239445);
    assert(parseDate("xyzzy") == :else);
    assert(parseDate("") == :else);
    assert(parseDate("9300-01-01") == :else);
}

long unixTime() => "date +%s".readback.atoi;

extern(C) int sleep(int);

// A version of readback that handles error code return values.
// FIXME: Replace with a stdlib version once one is available.
(int | string) readbackErr(string command) {
    import std.file : readText, remove;
    import std.string : toStringz;

    auto tmp = tmpnam(null).cToString;
    // XXX: Add hack to pipe stderr to devnull, otherwise date will make noise
    // about bad dates to our stderr.
    int iret = neat_runtime_system_iret(command ~ " > " ~ tmp ~ " 2> /dev/null");
    auto ret = readText(tmp);
    remove(tmp);
    if (iret)
        return iret;
    return ret;
}

private extern(C) char* tmpnam(char*);
private extern(C) int neat_runtime_system_iret(string command);

// FIXME: Should be in stdlib.
long atol(string s) {
    import neat.runtime : atol;
    return atol(s);
}

string[] words(string s) => [a for a in s.split(" ") where !a.empty];

(int | :else) parseUnit(string s, string unit) {
    string scalar = s[0 .. $ - unit.length] if s.endsWith(unit) else return :else;

    return :else;
}

unittest {
    assert("15min".parseUnit("min") == 15);
    assert("".parseUnit("min") == :else);
    assert("15".parseUnit("min") == :else);
    assert("15nmin".parseUnit("min") == :else);
}
