module ntt;

macro import std.macro.assert;
macro import std.macro.listcomprehension;

import std.algorithm;
import std.argparse;
import std.error;
import std.file;
import std.process;
import std.stdio;
import std.string;

alias pingIntervalMinutes = 45;

void main(string[] args) {
    if (args.length < 2)
        return cmdStatus(args[1 .. $]);
    else if (args[1] == "status")
        return cmdStatus(args[2 .. $]);
    else if (args[1] == "sleep")
        cmdSleep;
    else if (args[1] == "task" || args[1] == "t")
        cmdTask(args[2 .. $]);
    else if (args[1] == "break" || args[1] == "b")
        cmdBreak(args[2 .. $]);
    else if (args[1] == "export")
        cmdExport;
    else if (args[1] == "msg")
        cmdMsg(args[2 .. $]);
    else
        usage;
}

void usage() {
    print("Usage: ntt <command> [<args>]");
    print("    status                     Display current status (default command)");
    print("      --minimal                  Display only unaccounted ping count");
    print("    sleep                      Delay until the time of next task ping");
    print("    task ([id] ([message]))    Mark last ping as worked on task");
    print("    break ([message])          Mark last ping as break time");
    print("    export                     Print export in timedot format to stdout");
    print("    msg message                Leave an arbitrary comment timestamped with current time");
}

void cmdStatus(string[] args) {
    auto parser = new UnixArgParser;
    parser.add("m", "minimal", :noArg, "Display only unaccounted ping count");

    // TODO: Print usage instead of just crashing (need to rewrite case block
    // to allow multi-statement response)
    auto result = parser.parse(args)
        .case(Error: assert(false));


    auto log = loadLog;
    auto unaccounted = log.unaccountedPings;

    if (result.has("minimal")) {
        if (!unaccounted.empty)
            print("$(unaccounted.length)");
        return;
    }

    print("Average ping interval is $pingIntervalMinutes min");
    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
    } else if (!log.dayIsStarted) {
        print("Nothing logged today yet, tag the last ping to start working.");
        print("Last ping was at $(unaccounted[$ - 1].formatted)");
    } else {
        print("Unaccounted pings after last entry today:");
        for (p in unaccounted) {
            print("x $(p.formatted)");
        }
    }
}

void cmdTask(string[] args) {
    auto log = loadLog;
    auto unaccounted = log.unaccountedPings;

    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
        return;
    }

    mut auto task = "\"";  // Ditto mark.
    mut auto comment = "";
    if (args.length >= 1) {
        // Special case, write comment directly.
        if (args[0] == "--") {
            comment = args[0 .. $].join(" ");
        } else {
            task = args[0];
            comment = args[1 .. $].join(" ");
        }
    }

    if (log.dayIsStarted) {
        // Not the first entry, fill in breaks.
        for (auto i in 0 .. unaccounted.length - 1) {
            Entry("-", unaccounted[i], "break", pingIntervalMinutes, "").appendToLog;
        }
        if (unaccounted.length > 1)
            print("Marked $(unaccounted.length - 1) breaks");
    }

    Entry("x", unaccounted[$ - 1], task, pingIntervalMinutes, comment).appendToLog;
    print("Clocked $pingIntervalMinutes min on $task for $(unaccounted[$ - 1].formatted)");
}

void cmdBreak(string[] args) {
    auto log = loadLog;
    auto unaccounted = log.unaccountedPings;

    if (unaccounted.empty) {
        print("Nothing to do yet, wait for next ping.");
        return;
    }

    if (log.dayIsStarted) {
        // Not the first entry, fill in breaks.
        for (auto i in 0 .. unaccounted.length - 1) {
            Entry("-", unaccounted[i], "break", pingIntervalMinutes, "").appendToLog;
        }
        if (unaccounted.length > 1)
            print("Marked $(unaccounted.length - 1) breaks");
    }

    Entry("-", unaccounted[$ - 1], "break", pingIntervalMinutes, args[0 .. $].join(" ")).appendToLog;
    print("Clocked break for $(unaccounted[$ - 1].formatted)");
}

void cmdExport() {
    auto log = loadLog;

    mut long[string][string] days;

    // Build a histogram.
    for (entry in log) {
        if (!entry.isTask)
            continue;

        auto day = entry.time.day;

        // XXX: Nested hashmap jank ahead.
        long[string] empty;
        mut auto dayBin = days.require(day, empty);
        dayBin[entry.task] = dayBin.get(entry.task, 0) + entry.durationMin;
        days[day] = dayBin;
    }

    // Print out the timedots.
    for (day in days.keys) {
        print("$day");

        auto dotColumn = [max task.length for task in days[day].keys] + 2;
        for (task in days[day].keys) {
            prit("$task");
            for (auto i in 0..(dotColumn - task.length))
                prit(" ");

            // Print a dot for every 15 minutes (crummy integer rounding to
            // closest).
            long nDots = (days[day][task] + 8) / 15;

            for (i in 0..nDots) {
                if (i > 0 && i % 4 == 0)
                    prit(" ");
                prit(".");
            }
            print("");
        }

        print("");
    }
}

void cmdMsg(string[] args) {
    if (args.empty) {
        print("No message text, aborting");
    }

    auto msg = "# $(now.formatted)  $(args[0 .. $].join(" "))";

    // TODO Use append-to-file op instead of full rewrite
    auto text = (logPath.readText() if logPath.exists else "") ~ "$msg\n";
    logPath.writeText(text);

    print("Logged $msg");
}

Entry[] loadLog() {
    mut Entry[] result;

    mut auto dittoTask = "unknown-task";

    for (line in logLines) {
        mut auto entry = Entry.fromString(line)? else continue;

        // Convert ditto marks into task names.
        if (entry.isTask) {
            if (entry.task == "\"")
                entry.task = dittoTask;
            else
                dittoTask = entry.task;
        }

        result ~= entry;
    }
    return result;
}

string[] logLines() => logPath.readText.strip.split("\n") if logPath.exists else [];

string logPath() {
    auto path = getEnv("XDG_DATA_HOME").notEmpty? else "$(getEnv("HOME"))/.local/share";
    return "$(path)/ntt/time.log";
}

struct Entry {
    /// Time of entry in unix time, corresponds to pings.
    string marker;
    long time;
    string task;
    long durationMin;
    string comment;

    static (Entry | :else) fromString(string s) {
        auto words = s.words;
        // Must have marker, timestamp, task and duration.
        if (words.length < 4)
            return :else;
        auto marker = words[0];
        auto time = parseDate(words[1])? else return :else;
        auto task = words[2];
        auto durationMin = words[3].parseScalar("min")? else return :else;

        return Entry(marker, time, task, durationMin, words[4 .. $].join(" "));
    }

    string toString() => "$marker $(time.formatted)  $task  $(durationMin)min  $comment".strip;

    bool isTask() => marker == "x" && task != "break";

    void appendToLog() {
        if (!logPath.exists)
            system("mkdir -p $(logPath.dirname)");
        assert(logPath.dirname.exists);

        // TODO Use append-to-file op instead of full file rewrite
        mut auto text = (logPath.readText() if logPath.exists else "");

        // Append newline when starting a new day.
        auto log = loadLog;
        if (!log.empty && log[$ - 1].time.day != this.time.day)
            text ~= "\n";

        // Append new entry to log.
        text ~= "$(this)\n";

        logPath.writeText(text);
    }
}

unittest {
    assert(Entry.fromString("") == :else);
    assert(Entry.fromString("# Some comment dunno") == :else);
    assert(Entry.fromString("x 2024-03-13T10:09:06+0200  ntt.base  15min") ==
        Entry("x", 1710317346, "ntt.base", 15, ""));
    assert(Entry.fromString("x 2024-03-13T10:09:06+0200  ntt.base  15nmin") ==
        :else);
}

/// Pings between latest entry and now (limited to today).
long[] unaccountedPings(Entry[] entries) {
    auto today = now.day;
    auto limit = entries.latest;
    mut long[] result;
    mut long t = now.prevPing;
    while (t > limit && t.day == today) {
        result ~= t;
        t = t.prevPing;
    }

    return result.reversed;
}

/// Latest entry timestamp from list.
long latest(Entry[] entries) => [max(e.time) for e in entries] if !entries.empty else 0;

/// Return whether logging has started for today.
bool dayIsStarted(Entry[] entries) => entries.latest.day == now.day;

/// Sleep until it's time to ping
void cmdSleep() {
    print("Sleeping until next ping, average ping interval is $pingIntervalMinutes min");
    long targetTime = now.nextPing;

    // Don't try to sleep all the way to the target time at once, instead take
    // short naps and keep watching the clock. The OS might get suspended at
    // any time and that will screw up the timing of a long sleep.
    while (now < targetTime) {
        sleep(10);
    }

    print("Pinged at $(targetTime.formatted).");
}

/// Unix time of next ping from now given average ping interval.
long nextPing(long t) {
    mut long ret = t + 1;
    while (!isPing(pingIntervalMinutes * 60, ret)) ++ret;
    return ret;
}

/// Unix time of previous ping from now given average ping interval.
long prevPing(long t) {
    mut long ret = t - 1;
    while (!isPing(pingIntervalMinutes * 60, ret)) --ret;
    return ret;
}

bool isPing(long avgSecs, long t) {
  // This is the xorshift64 algorithm.

  mut long t = t;
  t ^= t << 13;
  t ^= t >> 7;
  t ^= t << 17;
  return (t % avgSecs) == 0;
}

string formatted(long unixTime) =>
    "date -d @$unixTime +'%Y-%m-%dT%H:%M:%S%z'".readback.strip;

(long | :else) parseDate(string datestring) {
    if (datestring.strip == "") {
        return :else;
    }

    if (datestring.strip.startsWith("#")) {
        return :else;
    }

    return "date -d $datestring -u +%s".readbackErr.case(
        int i: :else,
        string s: s.parseNum?.(:else if (that <= 0 || that > 99999999999) else that));
}

unittest
{
    assert(parseDate("2006-01-02T15:04:05-0700") == 1136239445);
    assert(parseDate("xyzzy") == :else);
    assert(parseDate("") == :else);
    assert(parseDate("9300-01-01") == :else);
}

long now() => "date +%s".readback.parseNum? else assert(false);

/// Day of unix timestamp in current time zone.
string day(long unixTime) => unixTime.formatted[0 .. 10];

extern(C) int sleep(int);

// A version of readback that handles error code return values.
// FIXME: Replace with a stdlib version once one is available.
(int | string) readbackErr(string command) {
    import std.file : readText, remove;
    import std.string : toStringz;

    auto tmp = tmpnam(null).cToString;
    // XXX: Add hack to pipe stderr to devnull, otherwise date will make noise
    // about bad dates to our stderr.
    int iret = neat_runtime_system_iret(command ~ " > " ~ tmp ~ " 2> /dev/null");
    auto ret = readText(tmp);
    remove(tmp);
    if (iret)
        return iret;
    return ret;
}

private extern(C) char* tmpnam(char*);
private extern(C) int neat_runtime_system_iret(string command);

string[] words(string s) => [a for a in s.split(" ") where !a.empty];

(long | :else) parseScalar(string s, string unit) {
    string scalar = s[0 .. $ - unit.length] if s.endsWith(unit) else return :else;
    return scalar.parseNum;
}

unittest {
    assert("15min".parseScalar("min") == 15);
    assert("".parseScalar("min") == :else);
    assert("15".parseScalar("min") == :else);
    assert("15nmin".parseScalar("min") == :else);
}

/// Robust integer parser.
(long | :else) parseNum(string s) {
    import neat.runtime : atol;

    auto s = s.strip;
    long ret = atol(s);
    return ret if "$ret" == s else :else;
}

unittest {
    assert(parseNum("123") == 123);
    assert(parseNum("-123") == -123);
    assert(parseNum("-") == :else);
    assert(parseNum("") == :else);
    assert(parseNum("123gfp") == :else);
    assert(parseNum("a123") == :else);
}

T[] reversed(T)(T[] xs) => [xs[$ - i - 1] for i in 0..xs.length];

unittest {
    int[] empty = [];   // Need to use a var so the generic type is fixed.
    assert(reversed(empty) == empty);

    assert(reversed([1, 2, 3]) == [3, 2, 1]);
    assert(reversed([1, 2, 3, 4]) == [4, 3, 2, 1]);
}

alias notEmpty = a => a if !a.empty else :else;

/// Print without \n
void prit(string str) {
    import neat.runtime.stdlib : fflush, printf,
        neat_runtime_lock_stdout, neat_runtime_unlock_stdout;

    neat_runtime_lock_stdout;
    printf("%.*s".ptr, cast(int) str.length, str.ptr);
    fflush(stdout);
    neat_runtime_unlock_stdout;
}
